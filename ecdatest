// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
/*

//using åº“å for ç±»å‹;

è®©è¯¥ç±»å‹çš„å˜é‡å¯ä»¥ç›´æ¥ä½¿ç”¨ è¯¥åº“çš„æ–¹æ³•


ECDSA æ˜¯ OpenZeppelin æä¾›çš„ ECDSA æ•°å­—ç­¾ååº“ã€‚

recover(bytes32 hash, bytes signature) â†’ address
ä½œç”¨ï¼šä»æ¶ˆæ¯å“ˆå¸Œï¼ˆhashï¼‰å’Œç­¾åï¼ˆsignatureï¼‰ä¸­è§£æå‡ºç­¾åè€…çš„ä»¥å¤ªåŠåœ°å€ã€‚
å‚æ•°ï¼š
hashï¼šæ¶ˆæ¯çš„å“ˆå¸Œå€¼ï¼ˆé€šå¸¸å·²æŒ‰ä»¥å¤ªåŠæ ‡å‡†æ ¼å¼åŒ–ï¼‰ã€‚
signatureï¼šç”¨æˆ·å¯¹å“ˆå¸Œçš„ç­¾åï¼ˆ65å­—èŠ‚ï¼Œæ ¼å¼ä¸ºr|s|vï¼‰ã€‚

toEthSignedMessageHash(bytes32 hash) â†’ bytes32
ä½œç”¨ï¼šå°†åŸå§‹å“ˆå¸Œè½¬æ¢ä¸ºä»¥å¤ªåŠç­¾åæ ‡å‡†æ ¼å¼ï¼Œé˜²æ­¢ç­¾åè¢«ç”¨äºå…¶ä»–åœºæ™¯ã€‚
åŸç†ï¼šæ·»åŠ å‰ç¼€ "\x19Ethereum Signed Message:\n32"ï¼Œç¡®ä¿ç­¾åä»…å¯¹ç‰¹å®šæ¶ˆæ¯æœ‰æ•ˆã€‚


abi.encode ä½œç”¨æ˜¯å°†å¤šä¸ªå‚æ•°æ‰“åŒ…æˆç»Ÿä¸€çš„å­—èŠ‚æ ¼å¼ï¼Œç¡®ä¿å“ˆå¸Œè®¡ç®—ä¸€è‡´æ€§
âœ… é˜²æ­¢å“ˆå¸Œç¢°æ’é—®é¢˜ï¼Œé¿å…ä¸åŒæ•°æ®ç»„åˆç”Ÿæˆç›¸åŒå“ˆå¸Œ
âœ… ä¿è¯ä¸åŒçš„é“¾ã€åˆçº¦ã€ç‰ˆæœ¬è®¡ç®—å‡ºçš„ DOMAIN_SEPARATOR å…·æœ‰å”¯ä¸€æ€§

æ‰€ä»¥ï¼Œabi.encode æ˜¯ EIP-712 ç»“æ„åŒ–ç­¾åçš„å…³é”®æ­¥éª¤ï¼Œç¡®ä¿ç­¾åéªŒè¯çš„å®‰å…¨æ€§å’Œå”¯ä¸€æ€§ï¼ ğŸš€


EIP-712 å…¨ç§°ä¸º â€œTyped Structured Data Hashing and Signingâ€ï¼Œæ˜¯ä¸€é¡¹ä»¥å¤ªåŠæ”¹è¿›ææ¡ˆï¼Œæ—¨åœ¨ä¸ºæ™ºèƒ½åˆçº¦æä¾›ä¸€ç§ç»“æ„åŒ–æ•°æ®çš„å“ˆå¸Œå’Œç­¾åæ ‡å‡†ã€‚å…¶ä¸»è¦ç›®çš„å’Œç‰¹ç‚¹åŒ…æ‹¬ï¼š

ç»“æ„åŒ–æ•°æ®ç­¾åï¼š
EIP-712 å®šä¹‰äº†ä¸€ç§æ ‡å‡†æ ¼å¼ï¼Œä½¿ç­¾åçš„æ•°æ®å…·æœ‰æ˜ç¡®çš„ç»“æ„ï¼ˆå³åŒ…å«å­—æ®µåç§°ã€ç±»å‹å’Œå€¼ï¼‰ï¼Œè¿™æ¯”ä¼ ç»Ÿåªå¯¹å­—ç¬¦ä¸²æˆ–å•ä¸€å“ˆå¸Œç­¾åæ›´å®‰å…¨ã€æ›´ç›´è§‚ã€‚ç»“æ„åŒ–ç­¾åè®©ç”¨æˆ·åœ¨ç­¾åæ—¶èƒ½å¤Ÿæ¸…æ¥šåœ°çœ‹åˆ°ä»–ä»¬æ­£åœ¨ç­¾ç½²çš„æ•°æ®å†…å®¹ã€‚

é˜²æ­¢ç­¾åæ··æ·†å’Œé‡æ”¾æ”»å‡»ï¼š
é€šè¿‡ä½¿ç”¨åŸŸåˆ†éš”ç¬¦ï¼ˆDomain Separatorï¼‰ï¼ŒEIP-712 å°†ç­¾åæ•°æ®ç»‘å®šåˆ°ç‰¹å®šçš„åº”ç”¨ã€åˆçº¦å’Œé“¾ä¸Šã€‚è¿™æ ·ï¼Œå³ä½¿åŒä¸€ä»½æ•°æ®åœ¨ä¸åŒç¯å¢ƒä¸‹ï¼Œç”Ÿæˆçš„å“ˆå¸Œä¹Ÿä¼šä¸åŒï¼Œä»è€Œæœ‰æ•ˆé˜²æ­¢ç­¾ååœ¨å…¶ä»–é“¾æˆ–åˆçº¦ä¸­è¢«é‡å¤ä½¿ç”¨ï¼ˆé‡æ”¾æ”»å‡»ï¼‰ã€‚

æé«˜å®‰å…¨æ€§å’Œç”¨æˆ·ä½“éªŒï¼š
ç”±äºç»“æ„åŒ–æ•°æ®åŒ…å«äº†æ•°æ®çš„ç±»å‹å’Œå­—æ®µä¿¡æ¯ï¼Œç”¨æˆ·åœ¨ç­¾ç½²æ•°æ®æ—¶å¯ä»¥æ›´ç›´è§‚åœ°çŸ¥é“è‡ªå·±åœ¨æˆæƒä»€ä¹ˆï¼Œå‡å°‘äº†å› ç­¾ç½²æ— æ„ä¹‰çš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²è€Œå¼•å‘çš„å®‰å…¨éšæ‚£ã€‚

æ ‡å‡†åŒ–äº’æ“ä½œï¼š
EIP-712 ä¸ºå‰åç«¯ã€ä¸åŒåˆçº¦ä¹‹é—´çš„ç­¾åå’ŒéªŒè¯æä¾›äº†ç»Ÿä¸€æ ‡å‡†ï¼Œä½¿å¾—å„æ–¹å¯ä»¥æŒ‰ç…§åŒä¸€è§„åˆ™ç”Ÿæˆå’ŒéªŒè¯ç­¾åï¼Œæé«˜äº†äº’æ“ä½œæ€§ã€‚

æ€»ç»“æ¥è¯´ï¼ŒEIP-712 æ˜¯ä¸€ç§ç”¨äºæ™ºèƒ½åˆçº¦ç­¾åçš„æ ‡å‡†ï¼Œå®ƒé€šè¿‡ç»“æ„åŒ–æ•°æ®å’ŒåŸŸåˆ†éš”ç¬¦ç¡®ä¿ç­¾åæ•°æ®çš„å®‰å…¨æ€§ã€å”¯ä¸€æ€§å’Œå¯éªŒè¯æ€§ï¼Œé˜²æ­¢é‡æ”¾æ”»å‡»ï¼Œå¹¶æå‡ç”¨æˆ·åœ¨ç­¾ç½²æ•°æ®æ—¶çš„é€æ˜åº¦ã€‚


bytes32 å’Œ string çš„åŒºåˆ«
å¯¹æ¯”é¡¹	bytes32	string
å­˜å‚¨æ–¹å¼	å›ºå®šé•¿åº¦ï¼ˆ32å­—èŠ‚ï¼‰	å¯å˜é•¿åº¦
å­˜å‚¨æ•ˆç‡	æ›´èŠ‚çœGas	è¾ƒå ç”¨Gas
ç”¨é€”	é€‚ç”¨äºå“ˆå¸Œå€¼ã€å›ºå®šé•¿åº¦æ•°æ®	é€‚ç”¨äºå¯å˜é•¿åº¦æ–‡æœ¬
å­—ç¬¦ä¸²å¤„ç†	ä¸èƒ½ç›´æ¥æ“ä½œå­—ç¬¦ä¸²ï¼Œéœ€è¦è½¬æ¢	é€‚åˆå­˜å‚¨å’Œæ“ä½œæ–‡æœ¬
æ¯”è¾ƒæ–¹å¼	å¯ç›´æ¥ == æ¯”è¾ƒ	éœ€è¦ keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2))
è½¬æ¢	éœ€è¦ string(abi.encodePacked(bytes32))	ä¸èƒ½ç›´æ¥è½¬æ¢ä¸º bytes32ï¼Œéœ€è¦ bytes32(abi.encodePacked(str))


bytes32 é€‚ç”¨äºå›ºå®šé•¿åº¦æ•°æ®ï¼Œå¦‚å“ˆå¸Œå€¼ã€æ ‡è¯†ç¬¦ç­‰ï¼Œå­˜å‚¨æ•ˆç‡é«˜ã€‚
string é€‚ç”¨äºå­˜å‚¨å¯å˜é•¿åº¦çš„æ–‡æœ¬ä¿¡æ¯ï¼Œä½†æ¶ˆè€—æ›´å¤šGasã€‚



*/

contract ecdatest{


    using ECDSA for bytes32;

     
     // å®šä¹‰ EIP-712 åŸŸåˆ†éš”ç¬¦ï¼ˆDomain Separatorï¼‰
    bytes32 private immutable DOMAIN_SEPARATOR;

    
    //// å®šä¹‰ç»“æ„åŒ–æ¶ˆæ¯çš„ç±»å‹å“ˆå¸Œï¼ˆType Hashï¼‰ 
    bytes32 private constant TRANSACTION_TYPEHASH = keccak256("Transaction(address from,address to,uint256 amount,uint256 nonce)");

    //// è®°å½•æ¯ä¸ªåœ°å€çš„ nonceï¼ˆé˜²é‡æ”¾ï¼‰
    mapping(address => uint256) public  nonces;
     
    //name ç‰ˆæœ¬å· é“¾id åˆçº¦åœ°å€
    constructor(){
        
        //æŒ‰ç…§eip-712æ ‡å‡† è·å¾—32å­—èŠ‚
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
            keccak256("ecdatest"),
            keccak256("1.0.0"),
            block.chainid,               // å½“å‰é“¾ID
            address(this)                // åˆçº¦åœ°å€
        ));
        
    } 
     

    function excuteTransfar(address to,uint256 value,bytes calldata signature) public {

        address from = msg.sender;
        uint256 cnonces = nonces[from];


        bytes32 shash = keccak256(abi.encode(
            TRANSACTION_TYPEHASH,from,to,value,cnonces
        )); 

         // 2. ç”Ÿæˆå®Œæ•´çš„ EIP-712 å“ˆå¸Œ
        bytes32 fullHash = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, shash));

        // 3. æ¢å¤ç­¾åè€…åœ°å€
        address signer = fullHash.recover(signature);
        require(signer == from, "Invalid signature");

        // 4. æ›´æ–° nonce å¹¶æ‰§è¡Œé€»è¾‘
        nonces[from]++;
        // æ­¤å¤„æ·»åŠ å®é™…è½¬è´¦é€»è¾‘ï¼ˆå¦‚è°ƒç”¨ ERC20 è½¬è´¦ï¼‰
        
    }




}
